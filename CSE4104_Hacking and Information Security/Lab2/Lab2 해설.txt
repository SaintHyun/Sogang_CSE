2번
stack canary가 적용되어 있음.
input code와 pass code의 주소는 stack canary와 관련이 없다. 또한 pass code의 길이는 8이상이어야 한다.
rsp+198에서 rsp+0x30과 rsp+0x10을 strcmp의 두 인자로 보내주는 것을 확인할 수 있다. 즉, 두 변수의 주소는 0x20, 10진수 32의 차이를 갖고 있음을 알 수 있다. 따라서, input code에 총 32의 길이를 가진 string을 입력하되, 앞의 8자리와 맨 뒤의 8자리를 같게 설정하고, 그 사이를 \0으로 채워주면 된다.
정답: a*8+\0*24+a*8

3번
print_secret 위치: 0x4008f6
rsp+4: i
rsp+8: quit_flag
rsp+12: choice
rsp+16: items
rsp+79: items 끝
rsp+104: main 위치
104-16= 84
fund.bin 코드에서는 items에 대한 idx가 정해진 범위를 넘는지 check하는 기능이 존재하지 않는다. 따라서 items 배열의 크기를 벗어난 수에 대해서도 산술 연산이 가능하다는 것에 착안한다. manage_fund 함수의 return address는 $rsp+104에 저장되어 있을 것이고, 그것을 실제로 확인하는 방법은 다음과 같다.
우선 gdb에서 b * 0x400c4f (즉, read_int 이전)에 break point를 걸어준다. 그 후 x/20xg $rsp로 rsp에 저장된 return address 값을 확인하면 0x400d15인데, 이것은 main 함수를 disas 해보면 알맞다는 것을 알 수 있다. 
즉, 이제 rsp+112에 저장된 값인 0x400d15를 print_secret의 위치로 수정해주기만 하면 된다. print_secret의 위치는 0x4008f6인데, 0x400d15-0x4008f6의 값은 10진수로 1055이다. 따라서 items 배열의 수정 값을 1055만큼 빼게 해주면 되는데, 그것에 해당하는 items의 인덱스는 22번, 즉, rsp+16+88 = rsp+104 의 값을 수정하게 한다. 이때 빼야하므로, src_idx에 저장되게 한다.
정답: 2, 22, (아무 숫자 <=21), 1055, 3

4번
print_secret 위치: 0x400926
\x26\x09\x40
read_memo에서 i가 음수인건 고려하지 않음. -> 이걸로 stack canary 값을 읽어야함.
write_memo에서는 24칸만 입력으로 받고, modify_memo에서는 최대 50칸까지 입력으로 받음 -> modify에서 bof를 내되, stack canary가 손상되지 않도록 해야한다.

read 함수 기준
cur_cnt는 rsp+4, marr의 주소는 rsp+8에 저장-> 따라가면  marr의 실질 값은 rsp+임
그리고 canary값은 rsp+에 존재한다. marr의 크기는 2+2+24=28byte, canary와 56byte차이가 나므로 따라서 read에서 -2를 입력하면 그곳에 도달한다. 그 값을 받아서 little endian으로 변환

modify 함수 기준
modify에서는 50칸이다. 우선 marr[9]를 활성화 시킨 다음, 9에 해당하는 값을 바꿔주되, canary쪽은 canary 값을 가져와서 손상되지 않도록 해야한다.
